package prefixSpan;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.flink.api.common.functions.GroupReduceFunction;
import org.apache.flink.api.common.functions.ReduceFunction;
import org.apache.flink.api.common.operators.Order;
import org.apache.flink.api.java.DataSet;
import org.apache.flink.api.java.ExecutionEnvironment;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.api.java.tuple.Tuple4;
import org.apache.flink.util.Collector;

/**
 * Input decoder for files generated by Big Bench.
 * @author Jens Röwekamp, Tianlong Du
 * Note: inputFile needs to lead to store_sales.dat of BigBench.
 */
public class BigBenchInputDecoder implements InputDecoder{
	
	private final String storeSalesMask = "11110000000000000000000"; //(sold_date, sold_time, item_id, customer_id)
	
	@Override
	public DataSet<Tuple2<Long,int[]>> parse(String inputFile, ExecutionEnvironment env) throws Exception {
		DataSet<Tuple4<Long, Long, Integer, Long>> storeSales = env.readCsvFile(inputFile)
				.lineDelimiter("\n").fieldDelimiter("|").includeFields(storeSalesMask).ignoreInvalidLines()
				.types(Long.class, Long.class, Integer.class, Long.class);
		DataSet<Tuple4<Long,Long,int[],Long>> itemSets = storeSales.groupBy(0,1,3).reduceGroup(new ItemSetReducer());
		List<Tuple4<Long,Long,int[],Long>> coll = itemSets.collect();
		DataSet<Tuple4<Long,Long,int[],Long>> orderedItemSets = env.fromCollection(coll).groupBy(0,1,3).reduce(new ItemSet2Reducer()).setParallelism(1);
		return orderedItemSets.groupBy(3).sortGroup(0, Order.ASCENDING).sortGroup(1, Order.ASCENDING).reduceGroup(new SequenceReducer()).setParallelism(1);
	}

	/**
	 * Extracts the itemsets based on sold_date, sold_time and customer.
	 * @author Jens Röwekamp, Tianlong Du
	 *
	 */
	private class ItemSetReducer implements GroupReduceFunction<Tuple4<Long,Long,Integer,Long>,Tuple4<Long,Long,int[],Long>>{
		private static final long serialVersionUID = 4656048402270572329L;
		@Override
		public void reduce(Iterable<Tuple4<Long, Long, Integer, Long>> items, Collector<Tuple4<Long,Long,int[],Long>> out)
				throws Exception {
			Set<Integer> itemSet = new HashSet<Integer>();
			Long customerId = 0L;
			Long date = 0L;
			Long time = 0L;
			boolean firstRun = false;
			for(Tuple4<Long,Long,Integer,Long> item : items){
				itemSet.add(item.f2);
				if(!firstRun){
					date = item.f0;
					time = item.f1;
					customerId = item.f3;
					firstRun = true;
				}
			}
			int[] itemArray = new int[itemSet.size()];
			int i=0;
			for(int item : itemSet){
				itemArray[i] = item;
				i++;
			}
			Arrays.sort(itemArray); //sort items in itemset ASC.
			out.collect(new Tuple4<Long,Long,int[],Long>(date,time,itemArray,customerId));
		}
	}
	
	/**
	 * Extracts the itemsets based on sold_date, sold_time and customer.
	 * @author Jens Röwekamp, Tianlong Du
	 *
	 */
	private class ItemSet2Reducer implements ReduceFunction<Tuple4<Long,Long,int[],Long>>{
		private static final long serialVersionUID = 1314031283845525902L;
		@Override
		public Tuple4<Long, Long, int[], Long> reduce(Tuple4<Long, Long, int[], Long> arg0,
				Tuple4<Long, Long, int[], Long> arg1) throws Exception {
			Set<Integer> itemSet = new HashSet<Integer>();
			for(int i=0; i<arg0.f2.length; i++){
				itemSet.add(arg0.f2[i]);
			}
			for(int i=0; i<arg1.f2.length; i++){
				itemSet.add(arg1.f2[i]);
			}
			int[] itemArray = new int[itemSet.size()];
			int i=0;
			for(int item : itemSet){
				itemArray[i] = item;
				i++;
			}
			Arrays.sort(itemArray);
			return new Tuple4<Long,Long,int[],Long>(arg0.f0,arg0.f1,itemArray,arg0.f3);
		}		
	}
	
	/**
	 * Creates the final database for prefixSpan by reducing all itemsets of one customer to one sequence.
	 * @author Jens Röwekamp, Tianlong Du
	 *
	 */
	private class SequenceReducer implements GroupReduceFunction<Tuple4<Long,Long,int[],Long>,Tuple2<Long,int[]>>{
		private static final long serialVersionUID = 7527116916768835257L;
		@Override
		public void reduce(Iterable<Tuple4<Long,Long,int[], Long>> itemSets, Collector<Tuple2<Long,int[]>> out)
				throws Exception {
			Long customerId = 0L;
			List<Integer> sequenceList = new ArrayList<Integer>();
			sequenceList.add(0); //add starting delimiting 0
			for(Tuple4<Long,Long,int[],Long> itemSet : itemSets){
				for(Integer item : itemSet.f2){
					sequenceList.add(item);
				}
				sequenceList.add(0); //add delimiting 0 after each itemSet
				customerId = itemSet.f3;
			}
			int[] sequence = new int[sequenceList.size()];
			for(int i=0; i<sequenceList.size(); i++){
				sequence[i] = sequenceList.get(i);
			}
			out.collect(new Tuple2<Long,int[]>(customerId,sequence));
		}
	}
}
